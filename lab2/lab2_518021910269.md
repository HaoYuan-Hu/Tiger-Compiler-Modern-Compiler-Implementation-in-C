## 一、如何处理comments

  **1、如果我们在 INITIAL 状态中，识别出了 /*** 

此时说明 COMMENT 状态开始。

```
<INITIAL>"/*" {adjust(); comment_count++; BEGIN COMMENT;}
```

此时我们通过 adjust 函数，跳过 /* ，识别comments内容。



**2、如果我们在 COMMENT 状态中，识别出了 /* 或 */**

此时即为正常的 comments 内容，但为了清楚，之后识别出的 $*/$ 对应的是哪一个 $/*$ ，

我们有必要定义一个计数器，来匹配对应的 comments 标识符。

```
<COMMENT>"/*" {adjust(); comment_count++;}
<COMMENT>"*/" {adjust(); comment_count--;
  if (comment_count == 0) {
    BEGIN INITIAL;
  }
}
```

当识别出 /* 时，计数器加1；当识别出 */ 时，计数器减1；

如果计数器减为0，则说明 COMMENT 状态结束，返回 INITIAL 状态。



**3、如果我们在 COMMENT 状态中，识别出了其余任何字符**

在 COMMENT 状态中，如果识别出了不同于以上所述的任何字符，

```
<COMMENT>. {adjust();}
```

让 COMMENT 状态下，正常识别其即可；



## 二、如何处理strings

**1、如果我们在 INITIAL 状态中，识别出了 ““；双引号之间，是除了 双引号以外的字符 或 \\$”$ **

此时即说明，我们识别出了一个字符串，需要进行相应的匹配操作；

```
<INITIAL>\"(\\\"|[^"])*\" {
  adjust();
  yylval.sval = getstr(yytext);
  return STRING;
}
```

匹配操作封装在了getstr函数中。



**2、如果 strings 为空，即“”**

为了通过test16，我们需要将 str_buf 设置为 "(null)"。

```
if (str_len == 2) {
    str_buf = "(null)";
    return str_buf;
  }
```



**3、如果识别出了 \\ ，则我们需要分类讨论**

```
if (i < str_len - 2 && str[i] == '\\') {
      if (str[i+1] == 'n') {
        str_buf[j] = '\n';
        i += 2;
      } else if (str[i+1] == 't') {
        str_buf[j] = '\t';
        i += 2;
      } else if (str[i+1] >= '0' && str[i+1] <= '9') {
        char c = (str[i+1]-'0')*10*10+(str[i+2]-'0')*10+str[i+3]-'0';
        str_buf[j] = c;
        i += 4;
      } else if (str[i+1] == '\\') {
        str_buf[j] = '\\';
        i += 2;
      } else if (str[i+1] == '\"') {
        str_buf[j] = '\"';
        i += 2;
      } else if (str[i+1] == '^') {
        str_buf[j] = str[i+2] - 'A' + 1;
        i += 3;
      } else {
        i++;
        while (i < str_len && str[i] != '\\') i++;
        i++;
        j--;
      }
}
```

如果后一个是n，则这是个换行符；如果后一个是t，则是个制表符；

如果后一个是[0-9]，则这是个ASC码，需要将其转成对应的字符；

如果后一个是\，则这是一个\，第一个\为转义符号；

如果后一个是"，则这是一个"，第一个\为转义符号；

如果后一个是^，则我们需要将后面的字符转成对应的ASC码与A的差值再加1；

如果不是以上列出的这些，则我们正常赋值即可。





## 三、如何处理error

 **1、如果我们在 INITIAL 状态中识别出了不属于任何上述字符，则通过**

```
<INITIAL>. {adjust(); EM_error(EM_tokPos, "illegal character"); BEGIN ERROR;}
<ERROR>.|"\n" {BEGIN INITIAL; yyless(0);}
```

将除第n个匹配字符之外的所有字符返回到输入流。



## 四、如何处理end-of-file

如果我们正常遇到了end-of-file，则其结尾一定会有一个end，INITIAL状态下可正常处理 

如果我们在 COMMENT 中遇到了end-of-file，我们需要报错并提示；

```
<COMMENT><<EOF>> {EM_error(EM_tokPos, "unclosed comments"); BEGIN ERROR;}
```



## 五、lexer的其他有趣的特性

 **1、对于多个制表符来说，lexer可以一次处理完他们**

```
[ \t]+ {adjust();}
```



